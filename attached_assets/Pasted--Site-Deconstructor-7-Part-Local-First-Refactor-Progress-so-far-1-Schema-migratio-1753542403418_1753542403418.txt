## ğŸš€ **Site Deconstructor â€“ 7â€‘Part Localâ€‘First Refactor**

Progress so far:

1. **Schema & migrations** âœ…
2. Optimistic **POSTÂ /scans** stub & redirect âœ…
3. **Worker & task fanâ€‘out** loop âœ…
4. **Reactâ€‘Query hooks + skeleton cards** â† *current task*
5. LocalStorage **panelâ€‘state** hook
6. **Realtime progress** subscription
7. **SupabaseÂ Auth** + RLS

### â›”Â Hard constraints for **Partâ€¯4 (Hooks & skeleton)**

* **Only** touch frontâ€‘end code: Reactâ€‘Query provider, hooks, and dashboard UI placeholders.
* Do **not** edit server code, worker logic, Auth, or CI configs.
* Provide a Replitâ€‘preview test that works even if Realtime and Auth arenâ€™t implemented yet.

---

# PartÂ 4Â /Â 7Â â€“Â Client data hooks & skeleton UI

\###Â ğŸ¯Â Goals

1. Add a **Reactâ€‘Query provider** at the app root (`client/src/main.tsx` or `App.tsx`).
2. Implement two hooks:

   * `useScanStatus(scanId: string)` â†’ fetches `/api/scans/${scanId}/status`.
   * `useTaskData(scanId: string, type: string)` â†’ fetches `/api/scans/${scanId}/task/${type}`.
3. Update **Dashboard page**:

   * Show a skeleton card for each task type (`tech`, `colors`, `seo`, `perf`).
   * Replace skeleton with data as soon as its hook resolves (independently).
4. Provide a local test: with worker running, dashboard fills in tech card first even if others are slow.

---

\##Â 1Â Â·Â Add Reactâ€‘Query provider
**File:** `client/src/main.tsx` (or topâ€‘level entry)

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>
);
```

\##Â 2Â Â·Â Hooks implementation
Create `client/src/hooks/useScanStatus.ts`:

```ts
import { useQuery } from "@tanstack/react-query";
export function useScanStatus(scanId: string) {
  return useQuery(["scanStatus", scanId], async () => {
    const res = await fetch(`/api/scans/${scanId}/status`);
    if (!res.ok) throw new Error("status fetch failed");
    return res.json(); // { status, progress }
  }, { refetchInterval: 2000 });
}
```

Create `client/src/hooks/useTaskData.ts`:

```ts
import { useQuery } from "@tanstack/react-query";
export function useTaskData(scanId: string, type: string) {
  return useQuery(["task", scanId, type], async () => {
    const res = await fetch(`/api/scans/${scanId}/task/${type}`);
    if (!res.ok) throw new Error("task fetch failed");
    return res.json();
  }, { staleTime: Infinity, refetchInterval: 5000 });
}
```

\##Â 3Â Â·Â Dashboard skeleton update
**File:** `client/src/pages/Dashboard.tsx`

```tsx
const taskTypes = ["tech", "colors", "seo", "perf"] as const;

return (
  <div className="grid gap-4">
    {taskTypes.map((t) => {
      const { data, isLoading } = useTaskData(scanId, t);
      return (
        <Card key={t}>
          <CardHeader>{t.toUpperCase()}</CardHeader>
          <CardContent>
            {isLoading ? <Skeleton className="h-24" /> : <pre>{JSON.stringify(data, null, 2)}</pre>}
          </CardContent>
        </Card>
      );
    })}
  </div>
);
```

Skeleton component can reuse Tailwind shimmer or simple gray box.

\##Â 4Â Â·Â Local test instructions

1. **ShellÂ A:** `npm run server` (Fastify API).
2. **ShellÂ B:** `npm run worker:dev` (stub workers).
3. **ShellÂ C:** `npm run dev` (Vite UI).
4. In preview: enter a URL â†’ dashboard loads.
5. Observe: tech card populates first (\~1â€‘3Â s) while others still show skeleton; once worker completes, remaining cards fill independently.

---

\###Â Commit

```bash
git add client/src/main.tsx client/src/hooks useScanStatus.ts useTaskData.ts client/src/pages/Dashboard.tsx
# plus any skeleton/UI component files if added
git commit -m "feat: add Reactâ€‘Query provider, data hooks, and skeleton dashboard cards"
```
