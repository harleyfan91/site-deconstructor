You are a **worldâ€‘class fullâ€‘stack developer** with deep expertise in NodeÂ +Â TypeScript, Next.js/React, Reactâ€‘Query, Playwright, Supabase, and lean migrations.

**Objective**: Deliver a "fastâ€‘feeling" UX: the user jumps from the URL entry field to the dashboard **instantly**, then sees perâ€‘section loaders that fill in as each slice of the analysis completes. **Do not create any new HTTP routes.** Work only with the alreadyâ€‘merged endpoints:

* `POST /api/scan` Â (idempotent trigger)
* `GETÂ  /api/overview?url=â€¦` Â (readâ€‘only cached blob)

Keep diffs minimal; touch as few files as necessary. Delete dead code rather than commenting.

---

## PhaseÂ AÂ â€”Â Backend: Early "pending / partial" responses

> **Goal**: `/api/overview` must return fast (<200Â ms) even when no scrape is cached.

### ADDÂ / MODIFY (in order)

1. **MODIFY** `server/lib/cache.ts` (or wherever `getOrCreateAnalysis(url)` lives)

   * If cache **misses**, immediately return `{ status:'pending', ui:null, seo:null, perf:null, schemaVersion:CURRENT }`.
   * Kick off `queue.enqueue(() => uiScraper.scrape(url))`; **do not await**.
2. **MODIFY** `uiScraper.scrape(url)` (or worker)

   * After each major slice completes (`ui`, `seo`, `perf`), write the *partial* JSON back to cache with `status:'partial'`.
   * At end of job, write the full JSON with `status:'complete'`.
3. **MODIFY tests**Â (if any) to expect `status` field.

### DELETE (after tests pass)

* Any blocking `await scrape()` calls inside `/api/overview` handler. It should read from cache only.

---

## PhaseÂ BÂ â€”Â Frontend: Instant nav + polling + perâ€‘card skeletons

### ADDÂ / MODIFY

1. **MODIFY** `UrlEntryForm.tsx` (or wherever submit happens)

   * On submit: `fetch('/api/scan', {method:'POST',body:{url}})` **without** await.
   * Immediately `router.push('/dashboard?url='+encodeURIComponent(url))`.
2. **MODIFY** `DashboardPage.tsx` (or page component)

   * `const { data, isLoading } = useQuery(['overview', url], fetchOverview, { refetchInterval: data?.status==='complete' ? false : 4000 })`.
3. **MODIFY** `UIAnalysisTab.tsx` and sibling tabs

   * Each card: `if (!data?.ui?.colors) return <SkeletonCard title="Colours"/>;` etc.
   * Global thin progress bar (e.g. NProgress) while `data?.status!=='complete'`.
4. **ADD** `SkeletonCard.tsx` (simple placeholder with shimmer).

### DELETE

* Any perâ€‘card fetch hooks that are still lingering; they arenâ€™t needed once cards read from overview blob.

---

## Validation Checklist

* **Network panel**: after URL submit, exactly **one** request to `/api/overview` every 4Â s until `status:'complete'`, then polling stops. No other endpoints hit.
* **Cold cache**: Dashboard appears â‰¤Â 300Â ms; each card shows skeletons that populate within 30Â s.
* **Warm cache**: Dashboard fully rendered â‰¤Â 500Â ms, no skeletons.
* **Routes**: still only `/api/scan` (POST) and `/api/overview` (GET).
* **Code hygiene**: `git grep 'useColors'`, `'/api/colors'`, etc. return no matches.
* **Tests**: Adjusted test suite passes (`npm test`).

---

## ðŸ¤– Agent Guidance

1. **Think before coding** â€“ map current cache helper & page flow; spend at least 3  min.
2. Follow *ADD/MODIFY first â†’ run dev server â†’ DELETE last* pattern.
3. Keep commit messages focused, e.g. `feat(overview): early pending payload` / `feat(ui): poll overview with skeletons` / `chore: remove obsolete hooks`.
